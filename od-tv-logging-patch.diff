From 7f2bc4c4624cf336f8c3fd01223a828e2d6447b9 Mon Sep 17 00:00:00 2001
From: Ryan McCombe <ryanmccombe@gmail.com>
Date: Thu, 18 Jun 2020 20:03:10 +0100
Subject: [PATCH] On Demand TV Logging

---
 src/app/lib/logger.const.js                   |   2 +
 .../logging/pathWithLogging/README.md         |  11 +-
 .../logging/pathWithLogging/index.js          |   2 +-
 .../logging/pathWithLogging/index.test.js     |   2 +-
 .../onDemandRadio/getInitialData/index.js     |  76 +++++----
 .../routes/onDemandTV/getInitialData/index.js | 148 +++++++++---------
 .../onDemandTV/getInitialData/index.test.js   |  58 ++++++-
 7 files changed, 177 insertions(+), 122 deletions(-)

diff --git a/src/app/lib/logger.const.js b/src/app/lib/logger.const.js
index ba68adcba..88026a26d 100644
--- a/src/app/lib/logger.const.js
+++ b/src/app/lib/logger.const.js
@@ -22,6 +22,8 @@ const logCodes = {
   MEDIA_PLAYER_STATUS: 'media_player_status',
   RADIO_EPISODE_EXPIRED: 'radio_episode_expired',
   RADIO_MISSING_FIELD: 'radio_missing_field',
+  TV_MISSING_FIELD: 'tv_missing_field',
+  TV_EPISODE_EXPIRED: 'tv_episode_expired',
 
   // Translations
   NO_TRANSLATION_FOUND: 'no_translation_found',
diff --git a/src/app/lib/utilities/logging/pathWithLogging/README.md b/src/app/lib/utilities/logging/pathWithLogging/README.md
index c5bd46215..37b60fadd 100644
--- a/src/app/lib/utilities/logging/pathWithLogging/README.md
+++ b/src/app/lib/utilities/logging/pathWithLogging/README.md
@@ -26,24 +26,21 @@ return {
 }
 ```
 
-## Options
-The "getter" function returned from `pathWithLogging` has a second parameter, where the following options can be modified:
-
-##### `logLevel` (default: info)
+## Modifying Log Level
 The verbosity of the log message.  Logs are created with an `info` verbosity by default.  This can be modified by importing the `LOG_LEVELS` object from the module:
 
 ```javascript
 import pathWithLogging, { LOG_LEVELS } from './';
 ```
 
-and then specifying a different log level for any field
+and then specifying a different log level for any field as the second parameter of the getter
 
 ```javascript
 const get = pathWithLogging('/bbc_dari_radio/123', 'radio-field-missing', pageData);
 
 return {
   id: get(['metadata', 'id']),  //  Uses LOG_LEVELS.INFO
-  title: get(['metadata', 'title'], { logLevel: LOG_LEVELS.WARN }),
-  description: get(['metadata', 'title'], { logLevel: LOG_LEVELS.ERROR })
+  title: get(['metadata', 'title'], LOG_LEVELS.WARN),
+  description: get(['metadata', 'title'], LOG_LEVELS.ERROR)
 }
 ```
\ No newline at end of file
diff --git a/src/app/lib/utilities/logging/pathWithLogging/index.js b/src/app/lib/utilities/logging/pathWithLogging/index.js
index 0aba341fe..263b3bddd 100644
--- a/src/app/lib/utilities/logging/pathWithLogging/index.js
+++ b/src/app/lib/utilities/logging/pathWithLogging/index.js
@@ -20,7 +20,7 @@ const getLoggingFunction = level =>
 
 const pathWithLogging = (url, logCategory, pageData) => (
   fieldPath,
-  { logLevel = LOG_LEVELS.INFO } = {},
+  logLevel = LOG_LEVELS.INFO,
 ) => {
   const field = path(fieldPath, pageData);
   if (isNil(field)) {
diff --git a/src/app/lib/utilities/logging/pathWithLogging/index.test.js b/src/app/lib/utilities/logging/pathWithLogging/index.test.js
index c21348c90..409270d6d 100644
--- a/src/app/lib/utilities/logging/pathWithLogging/index.test.js
+++ b/src/app/lib/utilities/logging/pathWithLogging/index.test.js
@@ -36,7 +36,7 @@ describe('pathWithLogging', () => {
       'a-different-url',
       'a-different-log-category',
       fixtureData,
-    )(['metadata', 'also-does-not-exist'], { logLevel: LOG_LEVELS.WARN });
+    )(['metadata', 'also-does-not-exist'], LOG_LEVELS.WARN);
 
     expect(loggerMock.warn).toHaveBeenCalledWith('a-different-log-category', {
       url: `a-different-url`,
diff --git a/src/app/routes/onDemandRadio/getInitialData/index.js b/src/app/routes/onDemandRadio/getInitialData/index.js
index 722e26df4..5bde0e89d 100644
--- a/src/app/routes/onDemandRadio/getInitialData/index.js
+++ b/src/app/routes/onDemandRadio/getInitialData/index.js
@@ -43,8 +43,6 @@ export default async ({ path: pathname }) => {
   // paremeters - the withError HOC will inspect these params and act accordingly
   if (!json) return rest;
 
-  const pageType = { metadata: { type: 'On Demand Radio' } };
-
   const availableFrom = getEpisodeAvailableFrom(json);
   const availableUntil = getEpisodeAvailableUntil(json);
   const episodeIsAvailable = getEpisodeAvailability({
@@ -58,46 +56,44 @@ export default async ({ path: pathname }) => {
 
   const withLogging = pathWithLogging(getUri(json), RADIO_MISSING_FIELD, json);
   const get = (fieldPath, logLevel) =>
-    logLevel ? withLogging(fieldPath, { logLevel }) : path(fieldPath, json);
+    logLevel ? withLogging(fieldPath, logLevel) : path(fieldPath, json);
 
   return {
     ...rest,
-    ...(json && {
-      pageData: {
-        language: get(['metadata', 'language'], LOG_LEVELS.INFO),
-        brandTitle: get(['metadata', 'title'], LOG_LEVELS.INFO),
-        episodeTitle: get(['content', 'blocks', 0, 'title']),
-        headline: get(['promo', 'headlines', 'headline'], LOG_LEVELS.WARN),
-        shortSynopsis: get(['promo', 'media', 'synopses', 'short']),
-        id: get(['metadata', 'id']),
-        summary: get(
-          ['content', 'blocks', 0, 'synopses', 'short'],
-          LOG_LEVELS.INFO,
-        ),
-        contentType: get(
-          ['metadata', 'analyticsLabels', 'contentType'],
-          LOG_LEVELS.INFO,
-        ),
-        episodeId: get(['content', 'blocks', 0, 'id'], LOG_LEVELS.ERROR),
-        masterBrand: get(['metadata', 'createdBy'], LOG_LEVELS.ERROR),
-        releaseDateTimeStamp: get(
-          ['metadata', 'releaseDateTimeStamp'],
-          LOG_LEVELS.WARN,
-        ),
-        pageTitle: get(['metadata', 'analyticsLabels', 'pageTitle']),
-        pageIdentifier: get(['metadata', 'analyticsLabels', 'pageIdentifier']),
-        imageUrl: get(['content', 'blocks', 0, 'imageUrl'], LOG_LEVELS.INFO),
-        promoBrandTitle: get(['promo', 'brand', 'title']),
-        durationISO8601: get(
-          ['promo', 'media', 'versions', 0, 'durationISO8601'],
-          LOG_LEVELS.INFO,
-        ),
-        thumbnailImageUrl: getPlaceholderImageUrlUtil(
-          get(['promo', 'media', 'imageUrl'], LOG_LEVELS.INFO),
-        ),
-        episodeIsAvailable,
-        ...pageType,
-      },
-    }),
+    pageData: {
+      metadata: { type: 'On Demand Radio' },
+      language: get(['metadata', 'language'], LOG_LEVELS.INFO),
+      brandTitle: get(['metadata', 'title'], LOG_LEVELS.INFO),
+      episodeTitle: get(['content', 'blocks', 0, 'title']),
+      headline: get(['promo', 'headlines', 'headline'], LOG_LEVELS.WARN),
+      shortSynopsis: get(['promo', 'media', 'synopses', 'short']),
+      id: get(['metadata', 'id']),
+      summary: get(
+        ['content', 'blocks', 0, 'synopses', 'short'],
+        LOG_LEVELS.INFO,
+      ),
+      contentType: get(
+        ['metadata', 'analyticsLabels', 'contentType'],
+        LOG_LEVELS.INFO,
+      ),
+      episodeId: get(['content', 'blocks', 0, 'id'], LOG_LEVELS.ERROR),
+      masterBrand: get(['metadata', 'createdBy'], LOG_LEVELS.ERROR),
+      releaseDateTimeStamp: get(
+        ['metadata', 'releaseDateTimeStamp'],
+        LOG_LEVELS.WARN,
+      ),
+      pageTitle: get(['metadata', 'analyticsLabels', 'pageTitle']),
+      pageIdentifier: get(['metadata', 'analyticsLabels', 'pageIdentifier']),
+      imageUrl: get(['content', 'blocks', 0, 'imageUrl'], LOG_LEVELS.INFO),
+      promoBrandTitle: get(['promo', 'brand', 'title']),
+      durationISO8601: get(
+        ['promo', 'media', 'versions', 0, 'durationISO8601'],
+        LOG_LEVELS.INFO,
+      ),
+      thumbnailImageUrl: getPlaceholderImageUrlUtil(
+        get(['promo', 'media', 'imageUrl'], LOG_LEVELS.INFO),
+      ),
+      episodeIsAvailable,
+    },
   };
 };
diff --git a/src/app/routes/onDemandTV/getInitialData/index.js b/src/app/routes/onDemandTV/getInitialData/index.js
index 5fbd5f7ac..901452109 100644
--- a/src/app/routes/onDemandTV/getInitialData/index.js
+++ b/src/app/routes/onDemandTV/getInitialData/index.js
@@ -1,90 +1,94 @@
-import path from 'ramda/src/path';
+import pathOr from 'ramda/src/pathOr';
 import fetchPageData from '../../utils/fetchPageData';
 import overrideRendererOnTest from '../../utils/overrideRendererOnTest';
 import getPlaceholderImageUrl from '../../utils/getPlaceholderImageUrl';
+import pathWithLogging, {
+  LOG_LEVELS,
+} from '#lib/utilities/logging/pathWithLogging';
+import { TV_MISSING_FIELD, TV_EPISODE_EXPIRED } from '#lib/logger.const';
 
-const getBrandTitle = path(['metadata', 'title']);
-const getLanguage = path(['metadata', 'language']);
-const getHeadline = path(['promo', 'headlines', 'headline']);
-const getId = path(['metadata', 'id']);
-const getShortSynopsis = path(['promo', 'media', 'synopses', 'short']);
-const getMasterBrand = path(['metadata', 'createdBy']);
-const getContentType = path(['metadata', 'analyticsLabels', 'contentType']);
-const getPageTitle = path(['metadata', 'analyticsLabels', 'pageTitle']);
-const getPageIdentifier = path([
-  'metadata',
-  'analyticsLabels',
-  'pageIdentifier',
-]);
-const getEpisodeId = path(['content', 'blocks', 0, 'id']);
-const getReleaseDateTimeStamp = path(['metadata', 'releaseDateTimeStamp']);
-const getDurationISO8601 = path([
-  'promo',
-  'media',
-  'versions',
-  0,
-  'durationISO8601',
-]);
-const getThumbnailImageUrl = json =>
-  getPlaceholderImageUrl(path(['promo', 'media', 'imageUrl'], json));
-const getPromoBrandTitle = path(['promo', 'brand', 'title']);
-const getImageUrl = path(['content', 'blocks', 0, 'imageUrl']);
-const getEpisodeAvailableFrom = path([
-  'content',
-  'blocks',
-  '0',
-  'versions',
-  '0',
-  'availableFrom',
-]);
-const getEpisodeAvailableUntil = path([
-  'content',
-  'blocks',
-  '0',
-  'versions',
-  '0',
-  'availableUntil',
-]);
+import nodeLogger from '#lib/logger.node';
 
-const getEpisodeAvailability = ({ availableFrom, availableUntil }) => {
+const logger = nodeLogger(__filename);
+
+const getEpisodeAvailability = ({ availableFrom, availableUntil, url }) => {
   const timeNow = Date.now();
-  if (!availableUntil || timeNow < availableFrom) return false;
+  if (!availableUntil || timeNow < availableFrom) {
+    logger.info(TV_EPISODE_EXPIRED, {
+      url,
+    });
+    return false;
+  }
   return true;
 };
 
+const getUrl = pageData =>
+  pathOr('Unknown', ['metadata', 'analyticsLabels', 'pageIdentifier'], pageData)
+    .replace('.page', '')
+    .replace(/\./g, '/');
+
 export default async ({ path: pathname }) => {
   const onDemandTvDataPath = overrideRendererOnTest(pathname);
   const { json, ...rest } = await fetchPageData(onDemandTvDataPath);
-  const pageType = { metadata: { type: 'On Demand TV' } };
+  if (!json) return rest;
+
+  const url = getUrl(json);
+
+  const get = pathWithLogging(url, TV_MISSING_FIELD, json);
+
+  const availableFrom = get([
+    'content',
+    'blocks',
+    '0',
+    'versions',
+    '0',
+    'availableFrom',
+  ]);
 
-  const availableFrom = getEpisodeAvailableFrom(json);
-  const availableUntil = getEpisodeAvailableUntil(json);
+  const availableUntil = get([
+    'content',
+    'blocks',
+    '0',
+    'versions',
+    '0',
+    'availableUntil',
+  ]);
 
   return {
     ...rest,
-    ...(json && {
-      pageData: {
-        language: getLanguage(json),
-        brandTitle: getBrandTitle(json),
-        id: getId(json),
-        headline: getHeadline(json),
-        shortSynopsis: getShortSynopsis(json),
-        contentType: getContentType(json),
-        pageTitle: getPageTitle(json),
-        pageIdentifier: getPageIdentifier(json),
-        releaseDateTimeStamp: getReleaseDateTimeStamp(json),
-        durationISO8601: getDurationISO8601(json),
-        thumbnailImageUrl: getThumbnailImageUrl(json),
-        promoBrandTitle: getPromoBrandTitle(json),
-        masterBrand: getMasterBrand(json),
-        episodeId: getEpisodeId(json),
-        imageUrl: getImageUrl(json),
-        episodeIsAvailable: getEpisodeAvailability({
-          availableFrom,
-          availableUntil,
-        }),
-        ...pageType,
-      },
-    }),
+    pageData: {
+      metadata: { type: 'On Demand TV' },
+      language: get(['metadata', 'language']),
+      brandTitle: get(['metadata', 'title']),
+      id: get(['metadata', 'id'], LOG_LEVELS.ERROR),
+      headline: get(['promo', 'headlines', 'headline'], LOG_LEVELS.WARN),
+      shortSynopsis: get(['promo', 'media', 'synopses', 'short']),
+      contentType: get(['metadata', 'analyticsLabels', 'contentType']),
+      pageTitle: get(['metadata', 'analyticsLabels', 'pageTitle']),
+      pageIdentifier: get(['metadata', 'analyticsLabels', 'pageIdentifier']),
+      releaseDateTimeStamp: get(
+        ['metadata', 'releaseDateTimeStamp'],
+        LOG_LEVELS.WARN,
+      ),
+      durationISO8601: get([
+        'promo',
+        'media',
+        'versions',
+        0,
+        'durationISO8601',
+      ]),
+      thumbnailImageUrl: getPlaceholderImageUrl(
+        get(['promo', 'media', 'imageUrl']),
+      ),
+      promoBrandTitle: get(['promo', 'brand', 'title']),
+      masterBrand: get(['metadata', 'createdBy'], LOG_LEVELS.ERROR),
+      episodeId: get(['content', 'blocks', 0, 'id'], LOG_LEVELS.ERROR),
+      imageUrl: get(['content', 'blocks', 0, 'imageUrl']),
+      episodeIsAvailable: getEpisodeAvailability({
+        availableFrom,
+        availableUntil,
+        url,
+      }),
+    },
   };
 };
diff --git a/src/app/routes/onDemandTV/getInitialData/index.test.js b/src/app/routes/onDemandTV/getInitialData/index.test.js
index 58f868221..890cce537 100644
--- a/src/app/routes/onDemandTV/getInitialData/index.test.js
+++ b/src/app/routes/onDemandTV/getInitialData/index.test.js
@@ -1,7 +1,12 @@
 import assocPath from 'ramda/src/assocPath';
+import pipe from 'ramda/src/pipe';
+import dissocPath from 'ramda/src/dissocPath';
+import map from 'ramda/src/map';
+import loggerMock from '#testHelpers/loggerMock';
 import getInitialData from '.';
 import * as fetchPageData from '../../utils/fetchPageData';
 import onDemandTvJson from '#data/pashto/bbc_pashto_tv/tv_programmes/w13xttn4';
+import { TV_MISSING_FIELD, TV_EPISODE_EXPIRED } from '#lib/logger.const';
 
 fetch.mockResponse(JSON.stringify(onDemandTvJson));
 const { env } = process;
@@ -49,7 +54,7 @@ describe('Get initial data for on demand tv', () => {
     expect(pageData.episodeIsAvailable).toEqual(true);
   });
 
-  it('should return episodeIsAvailable as false if episode is not available to watch', async () => {
+  it('should return episodeIsAvailable as false and create a log if episode is not available to watch', async () => {
     const pageDataWithoutVersions = assocPath(
       ['content', 'blocks', 0, 'versions'],
       [],
@@ -58,5 +63,56 @@ describe('Get initial data for on demand tv', () => {
     fetch.mockResponse(JSON.stringify(pageDataWithoutVersions));
     const { pageData } = await getInitialData('some-ondemand-tv-path');
     expect(pageData.episodeIsAvailable).toEqual(false);
+    expect(loggerMock.info).toHaveBeenCalledWith(TV_EPISODE_EXPIRED, {
+      url: 'pashto/bbc_pashto_tv/w172xcldhhrdqgb',
+    });
+  });
+
+  it('invokes logging when expected data is missing in fetchData response', async () => {
+    const errorFields = [
+      ['metadata', 'id'],
+      ['metadata', 'createdBy'],
+      ['content', 'blocks', 0, 'id'],
+    ];
+
+    const warnFields = [
+      ['promo', 'headlines', 'headline'],
+      ['metadata', 'releaseDateTimeStamp'],
+    ];
+
+    const infoFields = [
+      ['content', 'blocks', '0', 'versions', '0', 'availableFrom'],
+      ['content', 'blocks', '0', 'versions', '0', 'availableUntil'],
+      ['metadata', 'language'],
+      ['metadata', 'title'],
+      ['promo', 'media', 'synopses', 'short'],
+      ['metadata', 'analyticsLabels', 'contentType'],
+      ['metadata', 'analyticsLabels', 'pageTitle'],
+      ['metadata', 'analyticsLabels', 'pageIdentifier'],
+      ['promo', 'media', 'versions', 0, 'durationISO8601'],
+      ['promo', 'media', 'imageUrl'],
+      ['promo', 'brand', 'title'],
+      ['content', 'blocks', 0, 'imageUrl'],
+    ];
+
+    const pageDataWithMissingFields = pipe(
+      ...map(dissocPath, [...errorFields, ...warnFields, ...infoFields]),
+      JSON.stringify,
+    )(onDemandTvJson);
+
+    fetch.mockResponse(pageDataWithMissingFields);
+
+    await getInitialData({
+      path: 'mock-on-demand-tv-path',
+    });
+
+    const countMissingFieldCalls = mockedFunction =>
+      mockedFunction.mock.calls.filter(
+        ([logCategory]) => logCategory === TV_MISSING_FIELD,
+      ).length;
+
+    expect(countMissingFieldCalls(loggerMock.error)).toBe(errorFields.length);
+    expect(countMissingFieldCalls(loggerMock.warn)).toBe(warnFields.length);
+    expect(countMissingFieldCalls(loggerMock.info)).toBe(infoFields.length);
   });
 });
-- 
2.20.1

